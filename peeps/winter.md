# winter

### 2023-04-07 10:53 - open-source and goeevernments

yesterday in your cast of the 1v1 game, you mentioned that you'd like to see the income bars a little bit bigger and more accessible to casters (perhaps in graph format) for them to show. I too would really love the feature, because I pretty much exclusively watch casts of the game, and would love to see the same thing. when you said the feature idea, I could see a picture in my head of the one in sc2 where it shows the resource delta for the two opposing factions.

this gives me an opportunity to talk about programming and open-source in general (I hypenate the idea, because the whole idea of "open source" in in its many flavours of GPL, MIT, BSD are all similar in principle, that the source is publically available, disipte dfferences in the license). I perceive open-source a bit like a government, in that there are essentially *finite* programming resources available for any project; and, the programmers are the politicians. therefore, the features/issues that feel the most desirable to the programmers to accomplish are the ones that end up getting done. I call this style of interaction the value-desire model and it's motivated (in some larger corporations) monetarily, but usually dictatorally with an iron fist (whatever the chain of command going up to the CEO wants); obviously, this (usually) isn't present in an open-source project.

in an open-source project, because there is no value motivation it doesn't matter how great or valuable the thing is, if itt's not desirable, it simply won't get programming resources allocated to it. this is where the idea of lobbying starts to come into effect. players have their own desire for new features, and in order to get those desires into the game, they need to be promoted/lobbied in a way which makes the desire to the player to also become desirable to the programmers, as well (remember, they're just volunteering anyway).

there is, often times, a very big gap between the reality of the player who is playing a finished product with finite game resources, where all things desirable take the amount of build time in the game. a programmer, OTH, is playing with a (usually very) unfinished product, but has infinite game resources and everything builds instantly -- so the limitation they see is looked at in terms of implementation cost. it's a very different frame of mind. the difference between the two is simply the "physicality" of the desire: the more physical (well defined) the desire is, the easier it is to implement. I'll now demonstrate:

in bar, there are two (or three) different resources to show in the graph that you're wanting to display: metal and energy(and maybe buildpower used/available). we're going to imagine the x-axis as the temporal component, -- but obviously the energy and metal deltas grows at very different rates. therefore, the y-axis cannot be all the same. therefore, we must imagine two (or maybe three) graphs overlaid on top of each other.

those graphs already exist essentially, in the end-game statistics screen, so we can imagine that the technology/capacity to make those graphs is going to be the code that's used/copied to make the new graph. so let's look at the differences:

1. the line needs to be much thicker
2. two lines: one yellow/energy and one silver/metal will show the delta between the *two* (cause more would break the graph) sides (one above the x-axis and one below)
3. the delta legend needs to show on the right/left side, both the peak metal and the peak energy production amounts (along with a few between amounts maybe at 2/3 and 1/3 or something)

pretty easy. now, all that needs to be done is to create an image with this mock (if possible), because visuals really help a lot to make something feel "easy" to one of the programmers to implement -- simply because they can see it really easily. put those finite number of differences to existing functionality into the list to additionally make the feature feel more "easy" (and desirable) for the programmer to accomplish. what he'll be thinking is "wow, that's like an easy thing to do, and the result (which I'm looking at) is pretty cool." -- and so then their ego and desire to show off will get the best of them (least, anyway, that's how it works for me... lol)

that's a nice seguey into the next thing, which is to try and not conflate bugs/issues too much with desire. *every project* open source, or not will have a mountain of bugs and issues stacked up somewhere. because they're "issues", they're inherently a bit more undesirable than the other things that can be done. issues are kinda like the sewer system of the project. it's really not that sexy to be working on bugs.

I'll classify all things in a scale of desire and their related emotions here:
l. issues (fear, hate, unwanted)
2. improvements (it'd be nice, hopeful, butt usually no vision)
3. new functionality (desirable, but only when the other more important things are done)

it's a bit unfortunate that on github all aspects of the project are put into the first category. in fact, myself I read code a lot on github, and I'm a fairly sensitive person, so I feel oftentimes the same thing other people feel looking/observing the same thing -- and I can tell you that the issues page really has a lot of foreboding feeling to it. personally, I perfer to read the commits and the code instead, so I can feel what the various new features or bugfixes feel like to the programmer committing the change. there's a bit of euphoria associated with completing/committing something at the end of a lot of hard work.

some programmers (like me) enjoy the idea of going out and hanging out with others in a non-social environment after committing a new set of features. in a typical office environment, we would go down and get drinks and celebrate a bit after accomplishing something big. it was a nice reward for the effort and a huge emotional payoff, as well. this isn't often times present in open-source projects, simply because the programmers are often in different locations physically. therefore, I believe it's important to do a lot of "team building" exercises (aka "the drunk pump"), and what ends up happening here is that you get the guys out there and get them feeling really good about the progress you're making.
it's possible for this to backfire, if one isn't sincere about it. I'll explain from the perspective of a tech startup: imagine a CEO type that's got a much better financial recompense than you will ever hope to get from the project -- yet, because you *like* and believe in the project so much, you're excited to be doing all this work because you also play the game yourself and you really like what you're creating. the CEO guy needs to share in the excitement and actually find a way to appreciate the features/improvements (but not really issues because everyone hates those) that the programmer is producing for the team. for a game or social media product, that's pretty easy if you also use/play the game/product yourself. think of it this way: you like what they're creating for you (and the work they're doing), and you like them as a person -- so it's basically a perfect match in your mind. I've been in this position, and I just love people so much myself, so this comes unbelievably natural to me. so I'm trying to put into words what it is, but a personal connection and appreciation of the team is what makes you inspire good work from them. don't be a bill lumberg :)

that's all for now, cheers
kenny
